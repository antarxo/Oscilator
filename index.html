<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Προσομοίωση με Live Γραφική Παράσταση Θέσης</title>
  <!-- Φόρτωση της βιβλιοθήκης p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    body { margin: 0; padding: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
<script>
let amplitudeSlider, periodSlider, phaseSlider;
let startPauseButton, resetButton;
let startTime, startTimeOffset = 0;
let isRunning = false; // Ξεκινάει σε παύση
let sliderX = 20, sliderY = 20;

function setup() {
  createCanvas(800, 600);
  
  // Slider για το πλάτος (A): 0 έως 120, αρχική τιμή 60
  amplitudeSlider = createSlider(0, 120, 60, 1);
  amplitudeSlider.position(sliderX, sliderY);
  amplitudeSlider.style('width', '160px');
  amplitudeSlider.input(() => { if (!isRunning) redraw(); });
  
  // Slider για την περίοδο (T)
  periodSlider = createSlider(0.5, 5, 2, 0.1);
  periodSlider.position(sliderX, sliderY + 30);
  periodSlider.style('width', '160px');
  periodSlider.input(() => { if (!isRunning) redraw(); });
  
  // Slider για την αρχική φάση (φ) σε μοίρες: 0 έως 299
  phaseSlider = createSlider(0, 299, 0, 1);
  phaseSlider.position(sliderX, sliderY + 60);
  phaseSlider.style('width', '160px');
  phaseSlider.input(() => { if (!isRunning) redraw(); });
  
  // Κουμπί Start/Pause
  startPauseButton = createButton('Start');
  startPauseButton.position(sliderX, sliderY + 100);
  startPauseButton.mousePressed(toggleSimulation);
  
  // Κουμπί Reset
  resetButton = createButton('Reset');
  resetButton.position(sliderX + 80, sliderY + 100);
  resetButton.mousePressed(resetSimulation);
  
  startTime = millis();
  noLoop();  // Η προσομοίωση δεν τρέχει αυτόματα μέχρι να πατηθεί το "Start"
}

function draw() {
  background(240);
  
  // Ανάγνωση τιμών από τους sliders
  let A = amplitudeSlider.value();
  let T = periodSlider.value();
  let phiDegrees = phaseSlider.value();
  let phi = radians(phiDegrees);
  
  // Υπολογισμός χρόνου και γωνίας: θ = ωt + φ, όπου ω = 2π/T
  let t = (millis() - startTime) / 1000;
  let omega = TWO_PI / T;
  let theta = omega * t + phi;
  
  // --- Phase Diagram ---
  push();
  // Ορίζουμε το κέντρο του κύκλου (με μετατόπιση 60px δεξιότερα, x = 160)
  let centerX = 160;
  let centerY = height / 2;
  
  // Σχεδίαση κύκλου με ακτίνα ίση με το A
  stroke(0);
  noFill();
  ellipse(centerX, centerY, 2 * A, 2 * A);
  
  // Σχεδίαση αξόνων (ο οριζόντιος από 0 έως width+60)
  stroke(150);
  line(0, centerY, width + 60, centerY);
  line(centerX, centerY - A - 10, centerX, centerY + A + 10);
  
  // Υπολογισμός θέσης του γεμάτου κόκκινου σώματος (κλασική μέτρηση: x = centerX+A*cosθ, y = centerY - A*sinθ)
  let redBodyX = centerX + A * cos(theta);
  let redBodyY = centerY - A * sin(theta);
  
  // Σχεδίαση ακτίνας από το κέντρο προς το γεμάτο κόκκινο σώμα
  stroke(0, 150, 0);
  line(centerX, centerY, redBodyX, redBodyY);
  
  // Σχεδίαση γεμάτου κόκκινου σώματος
  fill(255, 0, 0);
  noStroke();
  ellipse(redBodyX, redBodyY, 15, 15);
  
  // Σχεδίαση της "σκιάς": σώμα με dotted κόκκινο περίγραμμα, το οποίο ταλαντεύεται στον άξονα ψ (δηλαδή έχει x = centerX και y = redBodyY)
  push();
  noFill();
  stroke(255, 0, 0);
  drawingContext.setLineDash([2, 2]); // dotted περίγραμμα
  ellipse(centerX, redBodyY, 15, 15);
  drawingContext.setLineDash([]);
  pop();
  
  // Με την ίδια dotted γραμμή (μαύρη) συνδέονται το γεμάτο κόκκινο σώμα και η "σκιά"
  push();
  stroke(0);
  drawingContext.setLineDash([2, 2]);
  line(redBodyX, redBodyY, centerX, redBodyY);
  drawingContext.setLineDash([]);
  pop();
  pop();
  
  // --- Γραφική Παράσταση Θέσης Live ---
  push();
  // Ο οριζόντιος άξονας του γραφήματος συμπίπτει με τον άξονα x του κύκλου.
  // Ο κατακόρυφος άξονας τοποθετείται στα δεξιά του κέντρου του κύκλου, σε απόσταση (maxAmplitude + 40px).
  // Δεδομένου ότι το ανώτατο όριο του slider για το A είναι 120, θεωρούμε maxAmplitude = 120.
  let graphOriginX = 160 + 120 + 40; // 160+120+40 = 320
  let graphWidth = 200;
  let graphHeight = 240;  // απεικόνιση από -120 έως +120
  let graphOriginY = centerY; // Συμπίπτει με τον οριζόντιο άξονα του κύκλου
  let scaleY = (graphHeight / 2) / 120;  // κλίμακα για την τιμή 120
  
  // Σχεδίαση αξόνων του γραφήματος
  stroke(0);
  // Κατακόρυφος (y) άξονας
  line(graphOriginX, graphOriginY - graphHeight / 2, graphOriginX, graphOriginY + graphHeight / 2);
  // Οριζόντιος (x) άξονας
  line(graphOriginX, graphOriginY, graphOriginX + graphWidth, graphOriginY);
  
  // Σχεδίαση της καμπύλης live: για t από 0 έως currentGraphTime (όπου currentGraphTime = min(t, T))
  let currentGraphTime = t < T ? t : T;
  let numPoints = 100;
  let fraction = currentGraphTime / T;
  let numPointsToDraw = floor(numPoints * fraction);
  noFill();
  stroke(0);
  beginShape();
  for (let i = 0; i <= numPointsToDraw; i++) {
    let tGraph = (i / numPoints) * T;
    let xGraph = graphOriginX + (tGraph / T) * graphWidth;
    // Η εξίσωση ταλάντωσης: y = -A*sin(ω*tGraph+φ) (με αρνητικό για να έχουμε θετικό ψ προς τα πάνω)
    let yGraph = graphOriginY + (-A * sin(omega * tGraph + phi)) * scaleY;
    vertex(xGraph, yGraph);
  }
  endShape();
  pop();
  
  // --- Προσομοίωση Ελατηρίου (Blue Body) ---
  push();
  let springX = width * 0.75;  // x θέση του ελατηρίου
  let fixedY = 50;           // θέση "ταβανιού"
  let eqY = height / 2;      // θέση ισορροπίας (κέντρο του καμβά)
  // Το μπλε σώμα ταλαντεύεται με την ίδια εξίσωση: y = eqY - A*sinθ (κατά κλασική μέτρηση)
  let massY = eqY - A * sin(theta);
  
  // Σχεδίαση του ελατηρίου
  stroke(0);
  noFill();
  beginShape();
  vertex(springX, fixedY);
  let numCoils = 12;
  let coilLength = (massY - fixedY) / numCoils;
  for (let i = 1; i < numCoils; i++) {
    let xOffset = (i % 2 === 0) ? 20 : -20;
    vertex(springX + xOffset, fixedY + i * coilLength);
  }
  vertex(springX, massY);
  endShape();
  
  // Σχεδίαση του μπλε σώματος
  fill(0, 0, 255);
  noStroke();
  ellipse(springX, massY, 40, 40);
  pop();
  
  // --- Δotted γραμμή που συνδέει το κέντρο της "σκιάς" με το κέντρο του μπλε σώματος ---
  push();
  stroke(0);
  drawingContext.setLineDash([1, 2]); // πιο dotted
  // Η "σκιά" έχει κέντρο (centerX, redBodyY) = (160, redBodyY)
  line(160, redBodyY, springX, massY);
  drawingContext.setLineDash([]);
  pop();
  
  // Εμφάνιση ετικετών για τους sliders
  push();
  fill(0);
  noStroke();
  text("Πλάτος (A): " + A, sliderX + 180, sliderY + 15);
  text("Περίοδος (T): " + nf(T, 1, 2) + " s", sliderX + 180, sliderY + 45);
  text("Αρχική Φάση (φ): " + phiDegrees + "°", sliderX + 180, sliderY + 75);
  pop();
}

function toggleSimulation() {
  if (isRunning) {
    startTimeOffset = millis() - startTime;
    noLoop();
    startPauseButton.html('Start');
  } else {
    startTime = millis() - startTimeOffset;
    loop();
    startPauseButton.html('Pause');
  }
  isRunning = !isRunning;
}

function resetSimulation() {
  startTime = millis();
  startTimeOffset = 0;
  if (!isRunning) {
    redraw();
  }
}
</script>
</body>
</html>
