<!DOCTYPE html>
<html lang="el">
<head>
  <meta charset="UTF-8">
  <title>Ταλάντωση και Αρχική Φάση</title>
  <!-- Google Font Roboto για μοντέρνα εμφάνιση -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
  <!-- Φόρτωση της βιβλιοθήκης p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <style>
    /* Στυλ παρόμοιο με το wavesfull.html */
    body, html {
      margin: 0;
      padding: 0;
      font-family: 'Roboto', sans-serif;
      background-color: #f7f7f7;
      overflow: hidden;
      height: 100vh;
    }
    .main-container {
      display: grid;
      grid-template-rows: auto 1fr;
      grid-template-columns: 1fr;
      grid-template-areas:
         "header"
         "canvas-area";
      height: 100vh;
    }
    .header {
      grid-area: header;
      background: #007BFF;
      color: #fff;
      text-align: center;
      padding: 15px;
      font-size: 24px;
    }
    .canvas-area {
      grid-area: canvas-area;
      position: relative;
    }
  </style>
</head>
<body>
  <div class="main-container">
    <div class="header">Ταλάντωση και Αρχική Φάση</div>
    <div class="canvas-area"></div>
  </div>
<script>
/* Global DOM elements για sliders, κουμπιά, κ.λπ. */
let amplitudeSlider, periodSlider, phaseSlider;
let startPauseButton, resetButton;
let sliderX = 20, sliderY = 120; // μετατοπισμένα ώστε να κατέβουν κάτω από τον τίτλο

// Flags για εμφάνιση στοιχείων μέσα στον καμβά (μέσω "checkboxes")
let showRedOutline = false;
let showGraph = false;
let showSpringBody = false;

let startTime, startTimeOffset = 0;
let isRunning = false; // Ξεκινάει σε παύση

function setup() {
  let canvas = createCanvas(800, 600);
  canvas.parent(select('.canvas-area'));
  
  // Sliders
  amplitudeSlider = createSlider(0, 120, 60, 1);
  amplitudeSlider.position(sliderX, sliderY);
  amplitudeSlider.style('width', '160px');
  amplitudeSlider.input(() => { if (!isRunning) redraw(); });
  
  periodSlider = createSlider(0.5, 5, 2, 0.1);
  periodSlider.position(sliderX, sliderY + 30);
  periodSlider.style('width', '160px');
  periodSlider.input(() => { if (!isRunning) redraw(); });
  
  phaseSlider = createSlider(0, 299, 0, 1);
  phaseSlider.position(sliderX, sliderY + 60);
  phaseSlider.style('width', '160px');
  phaseSlider.input(() => { if (!isRunning) redraw(); });
  
  // Κουμπιά – αρχικά θέτουμε dummy θέσεις (θα μετακινηθούν στο draw)
  startPauseButton = createButton('Start');
  resetButton = createButton('Reset');
  
  startTime = millis();
  noLoop();
}

function draw() {
  background(240);
  
  // Λήψη τιμών
  let A = amplitudeSlider.value();
  let T = periodSlider.value();
  let phiDegrees = phaseSlider.value();
  let phi = radians(phiDegrees);
  
  let t = (millis() - startTime) / 1000;
  let omega = TWO_PI / T;
  let theta = omega * t + phi;
  
  // --- Phase Diagram (Κύκλος) ---
  push();
  let centerX = 160; // Κέντρο του κύκλου (με μετατόπιση 60px δεξιότερα από 100)
  let centerY = height / 2;
  
  // Σχεδίαση κύκλου
  stroke(0);
  noFill();
  ellipse(centerX, centerY, 2 * A, 2 * A);
  
  // Σχεδίαση αξόνων του κύκλου
  stroke(150);
  line(0, centerY, width + 60, centerY);
  line(centerX, centerY - A - 10, centerX, centerY + A + 10);
  
  // Ετικέτες στο κύκλο
  fill(0);
  noStroke();
  textAlign(CENTER, CENTER);
  text("0", centerX - 10, centerY + 10);
  text("+A", centerX - 20 + 5, centerY - A - 5); // +A: 5px πιο δεξιά και 5px πιο πάνω
  text("-A", centerX - 20 + 5, centerY + A + 5); // -A: 5px πιο δεξιά και 5px πιο κάτω
  
  // Θέση γεμάτου κόκκινου σώματος: x = centerX + A*cosθ, y = centerY - A*sinθ
  let redBodyX = centerX + A * cos(theta);
  let redBodyY = centerY - A * sin(theta);
  
  // Σχεδίαση ακτίνας προς το γεμάτο σώμα
  stroke(0, 150, 0);
  line(centerX, centerY, redBodyX, redBodyY);
  
  // Σχεδίαση γεμάτου κόκκινου σώματος
  fill(255, 0, 0);
  noStroke();
  ellipse(redBodyX, redBodyY, 15, 15);
  
  // "Σκιά": κόκκινο περίγραμμα (εμφανίζεται μόνο αν showRedOutline==true)
  if (showRedOutline) {
    push();
    noFill();
    stroke(255, 0, 0);
    drawingContext.setLineDash([2, 2]);
    ellipse(centerX, redBodyY, 15, 15);
    drawingContext.setLineDash([]);
    pop();
    
    // Δotted γραμμή (μαύρη) που συνδέει το γεμάτο σώμα με τη "σκιά"
    push();
    stroke(0);
    drawingContext.setLineDash([2, 2]);
    line(redBodyX, redBodyY, centerX, redBodyY);
    drawingContext.setLineDash([]);
    pop();
  }
  pop();
  
  // --- Γραφική Παράσταση Θέσης Live ---
  if (showGraph) {
    push();
    let graphOriginX = centerX + 120 + 40; // 160+120+40 = 320
    let graphWidth = 200;
    let graphHeight = 240; // τιμές από -120 έως +120
    let graphOriginY = centerY;
    let scaleY = (graphHeight / 2) / 120;
    
    // Σχεδίαση αξόνων γραφήματος
    stroke(0);
    line(graphOriginX, graphOriginY - graphHeight / 2, graphOriginX, graphOriginY + graphHeight / 2);
    line(graphOriginX, graphOriginY, graphOriginX + graphWidth, graphOriginY);
    
    // Ετικέτες στους άξονες – μετατοπισμένες 10px αριστερότερα
    fill(0);
    noStroke();
    textAlign(CENTER, CENTER);
    text("ψ", graphOriginX, graphOriginY - graphHeight / 2);
    text("t", graphOriginX + graphWidth + 60 - 10, graphOriginY + 10);
    
    let n = floor(t / T);
    text("(" + n + "T, 0)", graphOriginX - 20, graphOriginY + 15);
    text((n + 1) + "T", graphOriginX + graphWidth, graphOriginY + 15);
    
    // Οριζόντιες dotted γραμμές για τις τιμές +A και -A
    push();
    stroke(0, 0, 0, 100);
    drawingContext.setLineDash([2, 2]);
    line(graphOriginX, graphOriginY - A * scaleY, graphOriginX + graphWidth, graphOriginY - A * scaleY);
    line(graphOriginX, graphOriginY + A * scaleY, graphOriginX + graphWidth, graphOriginY + A * scaleY);
    drawingContext.setLineDash([]);
    pop();
    
    // Ετικέτες για τα +A και -A στον άξονα ψ
    fill(0);
    textAlign(RIGHT, CENTER);
    text("+A", graphOriginX - 10, graphOriginY - A * scaleY);
    text("-A", graphOriginX - 10, graphOriginY + A * scaleY);
    
    // Live σχεδίαση της καμπύλης (για t από 0 έως min(t, T))
    let currentGraphTime = (t < T) ? t : T;
    let numPoints = 100;
    let fraction = currentGraphTime / T;
    let numPointsToDraw = floor(numPoints * fraction);
    noFill();
    stroke(0);
    beginShape();
    for (let i = 0; i <= numPointsToDraw; i++) {
      let tGraph = (i / numPoints) * T;
      let xGraph = graphOriginX + (tGraph / T) * graphWidth;
      let yGraph = graphOriginY + (-A * sin(omega * tGraph + phi)) * scaleY;
      vertex(xGraph, yGraph);
    }
    endShape();
    
    // Tracker: κόκκινο σημείο στην καμπύλη
    let tGraphCurrent = (t < T) ? t : (t % T);
    let xCurrent = graphOriginX + (tGraphCurrent / T) * graphWidth;
    let yCurrent = graphOriginY + (-A * sin(omega * tGraphCurrent + phi)) * scaleY;
    fill(255, 0, 0);
    noStroke();
    ellipse(xCurrent, yCurrent, 6, 6);
    
    // Δotted (αχνή) γραμμή που συνδέει το τελικό σημείο της καμπύλης με τον οριζόντιο άξονα
    let yFinal = graphOriginY + (-A * sin(omega * T + phi)) * scaleY;
    stroke(0, 0, 0, 100);
    drawingContext.setLineDash([1, 2]);
    line(graphOriginX + graphWidth, yFinal, graphOriginX + graphWidth, graphOriginY);
    drawingContext.setLineDash([]);
    pop();
  }
  
  // --- Προσομοίωση Ελατηρίου-Σώματος (Blue Body & Spring) ---
  if (showSpringBody) {
    push();
    let springX = width * 0.75 + 60; // μετατοπισμένο 60px δεξιότερα
    let fixedY = 50;
    let centerY = height / 2;
    let massY = centerY - A * sin(theta);  // το μπλε σώμα παρακολουθεί την ταλάντωση
    
    // Εφέ "ταβανιού": σχεδίαση οριζόντιας γραμμής μόνο πάνω από το ελατήριο
    stroke(50);
    strokeWeight(4);
    line(springX - 60, fixedY, springX + 60, fixedY);
    strokeWeight(1);
    
    // Σχεδίαση του ελατηρίου με τέλος στο massY
    stroke(0);
    noFill();
    beginShape();
    vertex(springX, fixedY);
    let numCoils = 12;
    let coilLength = (massY - fixedY) / numCoils;
    for (let i = 1; i < numCoils; i++) {
      let xOffset = (i % 2 === 0) ? 20 : -20;
      vertex(springX + xOffset, fixedY + i * coilLength);
    }
    vertex(springX, massY);
    endShape();
    
    // Σχεδίαση του μπλε σώματος
    fill(0, 0, 255);
    noStroke();
    ellipse(springX, massY, 40, 40);
    pop();
  }
  
  // --- Δotted γραμμή που συνδέει το κέντρο της "σκιάς" με το κέντρο του μπλε σώματος ---
  push();
  stroke(0);
  drawingContext.setLineDash([1, 2]);
  if (showSpringBody) {
    let springXForLine = width * 0.75 + 60;
    let massYForLine = height / 2 - A * sin(theta);
    line(160, redBodyY, springXForLine, massYForLine);
  }
  drawingContext.setLineDash([]);
  pop();
  
  // --- Σχεδίαση Checkboxes και Κουμπιών Ελέγχου μέσα στον καμβά ---
  drawCheckboxes();
  // Τοποθέτηση των κουμπιών κάτω από τα checkboxes – στοιχιμένα στο κέντρο του καμβά
  let btnY =  baseCheckboxY() + 30;
  startPauseButton.position(width/2 - 50, btnY);
  resetButton.position(width/2 + 10, btnY);
  
  // --- Ετικέτες για τα sliders (ευθυγραμμισμένες με τους sliders) ---
  push();
  fill(0);
  noStroke();
  textAlign(LEFT, CENTER);
  text("Πλάτος (A): " + A, sliderX + 180, sliderY + 15);
  text("Περίοδος (T): " + nf(T, 1, 2) + " s", sliderX + 180, sliderY + 45);
  text("Αρχική Φάση (φ): " + phiDegrees + "°", sliderX + 180, sliderY + 75);
  pop();
}

// Σχεδίαση checkboxes μέσα στον καμβά (στο κάτω μέρος, μία γραμμή)
function baseCheckboxY() {
  // Βάση για τα checkboxes: τοποθετούμε τα στο κάτω μέρος, κάτω από το γράφημα.
  return 520; // μπορείτε να προσαρμόσετε αν χρειάζεται
}

function drawCheckboxes() {
  let baseY =  baseCheckboxY();
  let boxSize = 15;
  textSize(14);
  textAlign(LEFT, CENTER);
  
  // Ομαδοποίηση στο κέντρο του καμβά: υπολογίζουμε ένα baseX ώστε ομαδοποιημένα να στοιχίζονται.
  let groupWidth = 400; // εκτιμώμενο συνολικό πλάτος για 3 checkboxes και τις ετικέτες τους
  let baseX = (width - groupWidth) / 2;
  
  // Checkbox 1: "Κόκκινο περίγραμμα"
  fill(255);
  stroke(0);
  rect(baseX, baseY, boxSize, boxSize);
  if (showRedOutline) {
    stroke(0);
    line(baseX, baseY, baseX + boxSize, baseY + boxSize);
    line(baseX + boxSize, baseY, baseX, baseY + boxSize);
  }
  noStroke();
  fill(0);
  text("Κόκκινο περίγραμμα", baseX + boxSize + 5, baseY + boxSize/2);
  
  // Checkbox 2: "Ελατήριο-Σώμα"
  let box2X = baseX + 150;
  fill(255);
  stroke(0);
  rect(box2X, baseY, boxSize, boxSize);
  if (showSpringBody) {
    stroke(0);
    line(box2X, baseY, box2X + boxSize, baseY + boxSize);
    line(box2X + boxSize, baseY, box2X, baseY + boxSize);
  }
  noStroke();
  fill(0);
  text("Ελατήριο-Σώμα", box2X + boxSize + 5, baseY + boxSize/2);
  
  // Checkbox 3: "Γραφική Παράσταση"
  let box3X = baseX + 300;
  fill(255);
  stroke(0);
  rect(box3X, baseY, boxSize, boxSize);
  if (showGraph) {
    stroke(0);
    line(box3X, baseY, box3X + boxSize, baseY + boxSize);
    line(box3X + boxSize, baseY, box3X, baseY + boxSize);
  }
  noStroke();
  fill(0);
  text("Γραφική Παράσταση", box3X + boxSize + 5, baseY + boxSize/2);
}

// Αντίδραση στο mouse click για τα checkboxes μέσα στον καμβά
function mousePressed() {
  let baseY = baseCheckboxY();
  let boxSize = 15;
  
  // Checkbox 1: "Κόκκινο περίγραμμα"
  let box1X = (width - 400) / 2;
  if (mouseX >= box1X && mouseX <= box1X + boxSize && mouseY >= baseY && mouseY <= baseY + boxSize) {
    showRedOutline = !showRedOutline;
    redraw();
  }
  // Checkbox 2: "Ελατήριο-Σώμα"
  let box2X = (width - 400) / 2 + 150;
  if (mouseX >= box2X && mouseX <= box2X + boxSize && mouseY >= baseY && mouseY <= baseY + boxSize) {
    showSpringBody = !showSpringBody;
    redraw();
  }
  // Checkbox 3: "Γραφική Παράσταση"
  let box3X = (width - 400) / 2 + 300;
  if (mouseX >= box3X && mouseX <= box3X + boxSize && mouseY >= baseY && mouseY <= baseY + boxSize) {
    showGraph = !showGraph;
    redraw();
  }
  
  // Επίσης, εάν γίνει κλικ σε κάποια περιοχή των DOM κουμπιών, ας μην παρεμβαίνει εδώ
}

function toggleSimulation() {
  if (isRunning) {
    startTimeOffset = millis() - startTime;
    noLoop();
    startPauseButton.html('Start');
  } else {
    startTime = millis() - startTimeOffset;
    loop();
    startPauseButton.html('Pause');
  }
  isRunning = !isRunning;
}

function resetSimulation() {
  startTime = millis();
  startTimeOffset = 0;
  if (!isRunning) {
    redraw();
  }
}
</script>
</body>
</html>
